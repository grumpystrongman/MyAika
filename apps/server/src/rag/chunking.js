const DEFAULT_MIN_CHARS = Number(process.env.RAG_CHUNK_MIN_CHARS || 700);
const DEFAULT_MAX_CHARS = Number(process.env.RAG_CHUNK_MAX_CHARS || 1200);
const DEFAULT_OVERLAP_RATIO = Number(process.env.RAG_CHUNK_OVERLAP_RATIO || 0.18);

function normalizeText(text) {
  return String(text || "").replace(/\s+/g, " ").trim();
}

function isBoilerplateLine(line) {
  const t = line.toLowerCase();
  if (!t) return true;
  if (t.includes("fireflies.ai")) return true;
  if (t.includes("transcribed by fireflies")) return true;
  if (t.includes("generated by fireflies")) return true;
  if (t.includes("meeting transcription")) return true;
  return false;
}

function splitSentences(text) {
  const cleaned = normalizeText(text);
  if (!cleaned) return [];
  return cleaned.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [cleaned];
}

function buildLinesFromSentences(sentences = []) {
  return sentences
    .map(sentence => {
      const speaker = normalizeText(sentence?.speaker_name || sentence?.speaker || "");
      const text = normalizeText(sentence?.text || sentence?.raw_text || "");
      if (!text || isBoilerplateLine(text)) return null;
      const lineText = speaker ? `${speaker}: ${text}` : text;
      return {
        text: lineText,
        speaker: speaker || "",
        start_time: Number.isFinite(sentence?.start_time) ? sentence.start_time : null,
        end_time: Number.isFinite(sentence?.end_time) ? sentence.end_time : null
      };
    })
    .filter(Boolean);
}

function buildLinesFromRawText(rawText) {
  return splitSentences(rawText)
    .map(sentence => {
      const text = normalizeText(sentence);
      if (!text || isBoilerplateLine(text)) return null;
      return { text, speaker: "", start_time: null, end_time: null };
    })
    .filter(Boolean);
}

function collectOverlap(lines, overlapChars) {
  if (!lines.length || overlapChars <= 0) return [];
  let total = 0;
  const overlap = [];
  for (let i = lines.length - 1; i >= 0; i -= 1) {
    const line = lines[i];
    total += line.text.length + 1;
    overlap.push(line);
    if (total >= overlapChars) break;
  }
  return overlap.reverse();
}

export function buildTranscriptText(sentences, rawText) {
  const lines = sentences?.length ? buildLinesFromSentences(sentences) : buildLinesFromRawText(rawText);
  return lines.map(line => line.text).join("\n").trim();
}

export function chunkTranscript({ meetingId, sentences = [], rawText = "" }) {
  const minChars = DEFAULT_MIN_CHARS;
  const maxChars = DEFAULT_MAX_CHARS;
  const overlapChars = Math.round(maxChars * DEFAULT_OVERLAP_RATIO);
  const lines = sentences?.length ? buildLinesFromSentences(sentences) : buildLinesFromRawText(rawText);
  if (!lines.length) return [];

  const chunks = [];
  let current = [];
  let currentLen = 0;
  let chunkIndex = 0;

  function flushChunk() {
    if (!current.length) return;
    const text = current.map(item => item.text).join("\n").trim();
    if (!text) return;
    const speakers = Array.from(new Set(current.map(item => item.speaker).filter(Boolean)));
    const speaker = speakers.length === 1 ? speakers[0] : (speakers.length ? "Multiple" : "");
    const start_time = current[0]?.start_time ?? null;
    const end_time = current[current.length - 1]?.end_time ?? null;
    const token_count = Math.max(1, Math.ceil(text.length / 4));
    chunks.push({
      chunk_id: `${meetingId}:${chunkIndex}`,
      meeting_id: meetingId,
      chunk_index: chunkIndex,
      speaker,
      start_time,
      end_time,
      text,
      token_count
    });
    chunkIndex += 1;
  }

  for (const line of lines) {
    const lineLen = line.text.length + 1;
    if (currentLen + lineLen > maxChars && currentLen >= minChars) {
      flushChunk();
      current = collectOverlap(current, overlapChars);
      currentLen = current.reduce((sum, item) => sum + item.text.length + 1, 0);
    }
    current.push(line);
    currentLen += lineLen;
  }

  flushChunk();
  return chunks;
}
